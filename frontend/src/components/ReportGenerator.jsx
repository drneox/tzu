import jsPDF from 'jspdf';
import { useLocalization } from '../hooks/useLocalization';
import apiClient from '../services/apiClient';

const ReportGenerator = () => {
  const { t } = useLocalization();

  // Función auxiliar para obtener etiqueta de riesgo
  const getRiskLabel = (risk) => {
    if (risk >= 6) return t?.ui?.high_risk || 'High';
    if (risk >= 3) return t?.ui?.medium_risk || 'Medium';
    return t?.ui?.low_risk || 'Low';
  };

  const generateReport = async (
    serviceData, 
    threats, 
    getRiskValue, 
    getResidualRiskValue, 
    getCurrentRiskValue, 
    calculateInherentRisk,
    getOwaspSelectOptions,
    showNotification
  ) => {
    if (!serviceData || !threats || threats.length === 0) {
      showNotification(
        t?.ui?.no_data_title || 'No Data Available',
        t?.ui?.no_data_pdf || 'No hay datos disponibles para generar el informe',
        'warning'
      );
      return;
    }

    try {
      console.log('=== STARTING PDF GENERATION ===');
      console.log('Service data:', serviceData);
      console.log('Number of threats:', threats?.length || 0);
      
      // Crear un nuevo PDF
      const pdf = new jsPDF('p', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      let yPosition = 20;

      // Título del reporte
      pdf.setFontSize(20);
      pdf.setFont('helvetica', 'bold');
      pdf.text(t?.ui?.pdf_title || 'Threat Modeling Analysis Report', pageWidth / 2, yPosition, { align: 'center' });
      yPosition += 15;

      // Fecha de generación
      const currentDate = new Date().toLocaleDateString();
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.text(`${t?.ui?.pdf_generated_on || 'Generated on:'} ${currentDate}`, pageWidth / 2, yPosition, { align: 'center' });
      yPosition += 20;

      // Información del sistema
      pdf.setFontSize(16);
      pdf.setFont('helvetica', 'bold');
      pdf.text(t?.ui?.pdf_system_info || 'System Information', 20, yPosition);
      yPosition += 10;

      pdf.setFontSize(12);
      pdf.setFont('helvetica', 'normal');
      
      // Título del sistema
      pdf.setFont('helvetica', 'bold');
      pdf.text(t?.ui?.pdf_title_label || 'Title:', 20, yPosition);
      pdf.setFont('helvetica', 'normal');
      const titleLines = pdf.splitTextToSize(serviceData.title, pageWidth - 60);
      pdf.text(titleLines, 50, yPosition);
      yPosition += titleLines.length * 5 + 5;

      // Descripción del sistema
      pdf.setFont('helvetica', 'bold');
      pdf.text(t?.ui?.pdf_description_label || 'Description:', 20, yPosition);
      pdf.setFont('helvetica', 'normal');
      const descLines = pdf.splitTextToSize(serviceData.description, pageWidth - 60);
      pdf.text(descLines, 50, yPosition);
      yPosition += descLines.length * 5 + 15;

      // Agregar imagen del diagrama si existe
      yPosition = await addDiagramSection(pdf, serviceData, yPosition, pageWidth, pageHeight, t);

      // Amenazas
      if (yPosition + 30 > pageHeight) {
        pdf.addPage();
        yPosition = 20;
      }

      pdf.setFontSize(16);
      pdf.setFont('helvetica', 'bold');
      pdf.text(t?.ui?.pdf_threats_analysis || 'Threats Analysis', 20, yPosition);
      yPosition += 15;

      // Resumen ejecutivo de riesgos
      yPosition = addRiskSummary(pdf, threats, getCurrentRiskValue, yPosition, t);

      // Tabla de amenazas detallada
      yPosition = await addThreatDetails(
        pdf, 
        threats, 
        getRiskValue, 
        getResidualRiskValue, 
        getCurrentRiskValue, 
        calculateInherentRisk,
        getOwaspSelectOptions,
        getRiskLabel,
        yPosition, 
        pageWidth, 
        pageHeight, 
        t
      );

      // Agregar página de métricas y recomendaciones
      await addMetricsAndRecommendations(
        pdf, 
        threats, 
        getCurrentRiskValue, 
        getRiskValue, 
        getResidualRiskValue, 
        getRiskLabel,
        pageWidth, 
        pageHeight, 
        t
      );

      // Pie de página con créditos
      const footerY = pageHeight - 15;
      pdf.setFontSize(8);
      pdf.setFont('helvetica', 'italic');
      pdf.text(t?.ui?.pdf_credits || 'Generated by Threat Zero Utility (TZU)', pageWidth / 2, footerY, { align: 'center' });

      // Guardar el PDF
      const fileName = `Threat_Analysis_${serviceData.title.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`;
      pdf.save(fileName);

    } catch (error) {
      console.error('Error generating PDF:', error);
      showNotification(
        t?.ui?.pdf_error_title || 'PDF Generation Error',
        t?.ui?.pdf_error || 'Error generating PDF report. Please try again.',
        'error'
      );
    }
  };

  return { generateReport };
};

// Función auxiliar para agregar la sección del diagrama
const addDiagramSection = async (pdf, serviceData, yPosition, pageWidth, pageHeight, t) => {
  if (serviceData.diagram) {
    console.log('=== DIAGRAM SECTION ===');
    console.log('Diagram filename:', serviceData.diagram);
    
    if (yPosition + 80 > pageHeight) {
      pdf.addPage();
      yPosition = 20;
    }

    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t?.ui?.pdf_diagram_label || 'Diagram:', 20, yPosition);
    yPosition += 10;

    const imgUrl = `/diagrams/${serviceData.diagram}`;
    console.log('Full diagram URL:', imgUrl);
    
    try {
      // Verificar que la imagen esté accesible primero
      console.log('Testing image accessibility...');
      const testResponse = await apiClient.get(imgUrl, { 
        responseType: 'blob'
      });
      
      console.log('Image is accessible, content-type:', testResponse.headers['content-type']);
      
      // Si llegamos aquí, la imagen está accesible, usar el blob directamente
      const blob = testResponse.data;
      console.log('Got image blob, size:', blob.size, 'type:', blob.type);
      
      const dataUrl = await new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });
      
      console.log('✓ Image converted to data URL via blob, length:', dataUrl.length);
      
      if (dataUrl.length < 1000) {
        throw new Error('Generated data URL is too short, likely invalid image');
      }
      
      // Crear imagen temporal para obtener dimensiones
      const tempImg = new window.Image();
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => reject(new Error('Timeout loading temp image')), 5000);
        tempImg.onload = () => {
          clearTimeout(timeout);
          resolve();
        };
        tempImg.onerror = () => {
          clearTimeout(timeout);
          reject(new Error('Invalid image data'));
        };
        tempImg.src = dataUrl;
      });
      
      // Calcular dimensiones para el PDF
      const maxWidth = pageWidth - 40;
      const maxHeight = 100;
      let imgWidth = Math.min(maxWidth, tempImg.width / 2);
      let imgHeight = (tempImg.height * imgWidth) / tempImg.width;
      
      if (imgHeight > maxHeight) {
        imgHeight = maxHeight;
        imgWidth = (tempImg.width * imgHeight) / tempImg.height;
      }
      
      console.log('Adding image to PDF with dimensions:', imgWidth, 'x', imgHeight);
      pdf.addImage(dataUrl, 'JPEG', 20, yPosition, imgWidth, imgHeight);
      yPosition += imgHeight + 15;
      console.log('✓ Image successfully added to PDF!');
      
    } catch (error) {
      console.error('❌ Image loading failed:', error);
      
      // Mostrar mensaje de error detallado
      pdf.setFont('helvetica', 'italic');
      pdf.setFontSize(10);
      pdf.setTextColor(150, 150, 150);
      pdf.text(`⚠ Diagram could not be loaded: ${serviceData.diagram}`, 20, yPosition);
      pdf.text(`URL attempted: ${imgUrl}`, 20, yPosition + 5);
      pdf.text(`Error: ${error.message}`, 20, yPosition + 10);
      pdf.text('Please verify the diagram file exists and is accessible.', 20, yPosition + 15);
      pdf.setTextColor(0, 0, 0); // Resetear color
      yPosition += 25;
    }
  } else {
    console.log('No diagram specified for this system');
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'italic');
    pdf.setTextColor(150, 150, 150);
    pdf.text(t?.ui?.pdf_no_diagram || 'No diagram available for this system', 20, yPosition);
    pdf.setTextColor(0, 0, 0);
    yPosition += 15;
  }

  return yPosition;
};

// Función auxiliar para agregar el resumen de riesgos
const addRiskSummary = (pdf, threats, getCurrentRiskValue, yPosition, t) => {
  if (threats.length > 0) {
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t?.ui?.pdf_risk_summary || 'Summary', 20, yPosition);
    yPosition += 10;

    // Calcular estadísticas de riesgo
    const riskStats = {
      high: 0,
      medium: 0,
      low: 0,
      totalThreats: threats.length,
      remediatedThreats: threats.filter(t => t.remediation?.status).length,
      notRemediatedThreats: threats.filter(t => !t.remediation?.status).length
    };

    threats.forEach(threat => {
      const currentRisk = getCurrentRiskValue(threat.id);
      if (currentRisk >= 6) riskStats.high++;
      else if (currentRisk >= 3) riskStats.medium++;
      else riskStats.low++;
    });

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`${t?.ui?.pdf_total_threats || 'Total Threats:'} ${riskStats.totalThreats}`, 25, yPosition);
    yPosition += 5;
    pdf.text(`${t?.ui?.pdf_high_risk || 'High Risk'}: ${riskStats.high} | ${t?.ui?.pdf_medium_risk || 'Medium Risk'}: ${riskStats.medium} | ${t?.ui?.pdf_low_risk || 'Low Risk'}: ${riskStats.low}`, 25, yPosition);
    yPosition += 5;
    pdf.text(`${t?.ui?.pdf_remediated || 'Remediated:'} ${riskStats.remediatedThreats} | ${t?.ui?.pdf_not_remediated || 'Not Remediated:'} ${riskStats.notRemediatedThreats}`, 25, yPosition);
    yPosition += 15;
  }

  return yPosition;
};

// Función auxiliar para agregar detalles de amenazas
const addThreatDetails = async (
  pdf, 
  threats, 
  getRiskValue, 
  getResidualRiskValue, 
  getCurrentRiskValue, 
  calculateInherentRisk,
  getOwaspSelectOptions,
  getRiskLabel,
  yPosition, 
  pageWidth, 
  pageHeight, 
  t
) => {
  // Función auxiliar para obtener descripción del valor OWASP
  const getOwaspDescription = (factor, value) => {
    try {
      console.log(`PDF: Getting description for ${factor} = ${value}`);
      const options = getOwaspSelectOptions(factor, t);
      console.log(`PDF: Options for ${factor}:`, options);
      
      // Primero buscar coincidencia exacta
      const exactMatch = options.find(opt => opt.value === value);
      if (exactMatch) {
        const description = exactMatch.label.split(' - ')[1];
        console.log(`PDF: Exact match found: ${description}`);
        return description; // Solo la descripción, sin el número
      }
      
      // Si no hay coincidencia exacta, buscar el valor más cercano inferior
      const closestLower = options
        .filter(opt => opt.value <= value)
        .sort((a, b) => b.value - a.value)[0];
      
      if (closestLower) {
        const description = closestLower.label.split(' - ')[1];
        console.log(`PDF: Closest lower match found: ${description}`);
        return description;
      }
      
      // Si no hay valor inferior, usar el menor disponible
      if (options.length > 0) {
        const description = options[0].label.split(' - ')[1];
        console.log(`PDF: Using first available option: ${description}`);
        return description;
      }
      
      console.log(`PDF: No description found, returning default`);
      return `Valor ${value}`;
      
    } catch (error) {
      console.error(`PDF: Error getting description for ${factor} = ${value}:`, error);
      return `Valor ${value}`;
    }
  };

  threats.forEach((threat, index) => {
    if (yPosition + 80 > pageHeight) {
      pdf.addPage();
      yPosition = 20;
    }

    const inherentRisk = getRiskValue(threat.id) || calculateInherentRisk(threat.risk);
    const residualRisk = getResidualRiskValue(threat.id);
    const currentRisk = getCurrentRiskValue(threat.id);
    const isRemediated = threat.remediation?.status;

    // Título de la amenaza con número
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'bold');
    pdf.text(`${index + 1}. ${threat.title}`, 20, yPosition);
    yPosition += 10;

    // Tipos separados
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(10);
    
    if (threat.type) {
      const types = threat.type.split(',').map(type => type.trim()).filter(type => type.length > 0);
      const typesText = types.length > 1 ? `${t?.ui?.pdf_types || 'Types:'} ${types.join(' | ')}` : `${t?.ui?.pdf_type || 'Type:'} ${types[0] || threat.type}`;
      pdf.text(typesText, 25, yPosition);
      yPosition += 5;
    }
    
    // Descripción
    if (threat.description) {
      const threatDescLines = pdf.splitTextToSize(`${t?.ui?.pdf_description || 'Description:'} ${threat.description}`, pageWidth - 50);
      pdf.text(threatDescLines, 25, yPosition);
      yPosition += threatDescLines.length * 4 + 3;
    }
    
    // Remediación
    if (threat.remediation?.description) {
      const remedLines = pdf.splitTextToSize(`${t?.ui?.pdf_remediation || 'Remediation:'} ${threat.remediation.description}`, pageWidth - 50);
      pdf.text(remedLines, 25, yPosition);
      yPosition += remedLines.length * 4 + 3;
    }
    
    // Sección de análisis OWASP Risk Rating
    pdf.setFont('helvetica', 'bold');
    pdf.text(t?.ui?.pdf_owasp_analysis || 'OWASP Risk Rating Analysis:', 25, yPosition);
    yPosition += 7;
    
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(9);
    
    // Riesgo inherente
    pdf.text(`• ${t?.ui?.pdf_inherent_risk || 'Inherent Risk:'} ${inherentRisk.toFixed(1)} (${getRiskLabel(inherentRisk)})`, 30, yPosition);
    yPosition += 4;
    
    // Riesgo residual (si está definido manualmente)
    if (residualRisk && residualRisk !== inherentRisk) {
      pdf.text(`• ${t?.ui?.pdf_residual_risk || 'Residual Risk:'} ${residualRisk.toFixed(1)} (${getRiskLabel(residualRisk)}) ${t?.ui?.pdf_manual || '[Manual]'}`, 30, yPosition);
      yPosition += 4;
    }
    
    // Riesgo actual (dinámico basado en remediación)
    const currentRiskLabel = getRiskLabel(currentRisk);
    const riskSource = isRemediated ? (residualRisk ? 'residual' : 'inherent') : 'inherent';
    pdf.text(`• ${t?.ui?.pdf_current_risk || 'Current Risk:'} ${currentRisk.toFixed(1)} (${currentRiskLabel}) ${t?.ui?.pdf_based_on || '[Based on'} ${riskSource} risk]`, 30, yPosition);
    yPosition += 4;
    
    // Estado de remediación
    pdf.setFont('helvetica', 'bold');
    const statusText = isRemediated ? (t?.ui?.pdf_applied || 'APPLIED') : (t?.ui?.pdf_not_applied || 'NOT APPLIED');
    const statusColor = isRemediated ? [0, 128, 0] : [255, 0, 0]; // Verde o Rojo
    pdf.setTextColor(...statusColor);
    pdf.text(`${t?.ui?.pdf_remediation_status || 'Remediation Status:'} ${statusText}`, 25, yPosition);
    pdf.setTextColor(0, 0, 0); // Resetear a negro
    yPosition += 8;

    // Factores OWASP (si están disponibles)
    if (threat.risk && typeof threat.risk === 'object') {
      yPosition = addOwaspFactors(pdf, threat.risk, getOwaspDescription, yPosition, pageWidth, t);
    }
    
    yPosition += 8; // Espacio entre amenazas
  });

  return yPosition;
};

// Función auxiliar para agregar factores OWASP
const addOwaspFactors = (pdf, risk, getOwaspDescription, yPosition, pageWidth, t) => {
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(9);
  pdf.text(t?.ui?.pdf_owasp_factors || 'OWASP Risk Rating Factors:', 30, yPosition);
  yPosition += 5;
  
  pdf.setFont('helvetica', 'normal');
  pdf.setFontSize(8);
  
  // Threat Agent Factors (4 factores)
  if (risk.skill_level !== undefined || risk.motive !== undefined || 
      risk.opportunity !== undefined || risk.size !== undefined) {
    pdf.text(`${t?.ui?.pdf_threat_agent || 'Threat Agent:'} `, 35, yPosition);
    let factorText = [];
    if (risk.skill_level !== undefined) {
      const desc = getOwaspDescription('skill_level', risk.skill_level);
      factorText.push(`${t?.ui?.pdf_skill || 'Skill'}: ${risk.skill_level} (${desc})`);
    }
    if (risk.motive !== undefined) {
      const desc = getOwaspDescription('motive', risk.motive);
      factorText.push(`${t?.ui?.pdf_motive || 'Motive'}: ${risk.motive} (${desc})`);
    }
    if (risk.opportunity !== undefined) {
      const desc = getOwaspDescription('opportunity', risk.opportunity);
      factorText.push(`${t?.ui?.pdf_opportunity || 'Opportunity'}: ${risk.opportunity} (${desc})`);
    }
    if (risk.size !== undefined) {
      const desc = getOwaspDescription('size', risk.size);
      factorText.push(`${t?.ui?.pdf_size || 'Size'}: ${risk.size} (${desc})`);
    }
    
    if (factorText.length > 0) {
      const factorLines = pdf.splitTextToSize(factorText.join(', '), pageWidth - 80);
      pdf.text(factorLines, 70, yPosition);
      yPosition += factorLines.length * 3 + 2;
    }
  }
  
  // Vulnerability Factors (4 factores)
  if (risk.ease_of_discovery !== undefined || risk.ease_of_exploit !== undefined ||
      risk.awareness !== undefined || risk.intrusion_detection !== undefined) {
    pdf.text(`${t?.ui?.pdf_vulnerability || 'Vulnerability:'} `, 35, yPosition);
    let factorText = [];
    if (risk.ease_of_discovery !== undefined) {
      const desc = getOwaspDescription('ease_of_discovery', risk.ease_of_discovery);
      factorText.push(`${t?.ui?.pdf_discovery || 'Discovery'}: ${risk.ease_of_discovery} (${desc})`);
    }
    if (risk.ease_of_exploit !== undefined) {
      const desc = getOwaspDescription('ease_of_exploit', risk.ease_of_exploit);
      factorText.push(`${t?.ui?.pdf_exploit || 'Exploit'}: ${risk.ease_of_exploit} (${desc})`);
    }
    if (risk.awareness !== undefined) {
      const desc = getOwaspDescription('awareness', risk.awareness);
      factorText.push(`${t?.ui?.pdf_awareness || 'Awareness'}: ${risk.awareness} (${desc})`);
    }
    if (risk.intrusion_detection !== undefined) {
      const desc = getOwaspDescription('intrusion_detection', risk.intrusion_detection);
      factorText.push(`${t?.ui?.pdf_detection || 'Detection'}: ${risk.intrusion_detection} (${desc})`);
    }
    
    if (factorText.length > 0) {
      const factorLines = pdf.splitTextToSize(factorText.join(', '), pageWidth - 80);
      pdf.text(factorLines, 70, yPosition);
      yPosition += factorLines.length * 3 + 2;
    }
  }
  
  // Technical Impact Factors (4 factores)
  if (risk.loss_of_confidentiality !== undefined || risk.loss_of_integrity !== undefined ||
      risk.loss_of_availability !== undefined || risk.loss_of_accountability !== undefined) {
    pdf.text(`${t?.ui?.pdf_technical_impact || 'Technical Impact:'} `, 35, yPosition);
    let factorText = [];
    if (risk.loss_of_confidentiality !== undefined) {
      const desc = getOwaspDescription('loss_of_confidentiality', risk.loss_of_confidentiality);
      factorText.push(`${t?.ui?.pdf_confidentiality || 'Confidentiality'}: ${risk.loss_of_confidentiality} (${desc})`);
    }
    if (risk.loss_of_integrity !== undefined) {
      const desc = getOwaspDescription('loss_of_integrity', risk.loss_of_integrity);
      factorText.push(`${t?.ui?.pdf_integrity || 'Integrity'}: ${risk.loss_of_integrity} (${desc})`);
    }
    if (risk.loss_of_availability !== undefined) {
      const desc = getOwaspDescription('loss_of_availability', risk.loss_of_availability);
      factorText.push(`${t?.ui?.pdf_availability || 'Availability'}: ${risk.loss_of_availability} (${desc})`);
    }
    if (risk.loss_of_accountability !== undefined) {
      const desc = getOwaspDescription('loss_of_accountability', risk.loss_of_accountability);
      factorText.push(`${t?.ui?.pdf_accountability || 'Accountability'}: ${risk.loss_of_accountability} (${desc})`);
    }
    
    if (factorText.length > 0) {
      const factorLines = pdf.splitTextToSize(factorText.join(', '), pageWidth - 80);
      pdf.text(factorLines, 70, yPosition);
      yPosition += factorLines.length * 3 + 2;
    }
  }
  
  // Business Impact Factors (4 factores)
  if (risk.financial_damage !== undefined || risk.reputation_damage !== undefined ||
      risk.non_compliance !== undefined || risk.privacy_violation !== undefined) {
    pdf.text(`${t?.ui?.pdf_business_impact || 'Business Impact:'} `, 35, yPosition);
    let factorText = [];
    if (risk.financial_damage !== undefined) {
      const desc = getOwaspDescription('financial_damage', risk.financial_damage);
      factorText.push(`${t?.ui?.pdf_financial || 'Financial'}: ${risk.financial_damage} (${desc})`);
    }
    if (risk.reputation_damage !== undefined) {
      const desc = getOwaspDescription('reputation_damage', risk.reputation_damage);
      factorText.push(`${t?.ui?.pdf_reputation || 'Reputation'}: ${risk.reputation_damage} (${desc})`);
    }
    if (risk.non_compliance !== undefined) {
      const desc = getOwaspDescription('non_compliance', risk.non_compliance);
      factorText.push(`${t?.ui?.pdf_compliance || 'Compliance'}: ${risk.non_compliance} (${desc})`);
    }
    if (risk.privacy_violation !== undefined) {
      const desc = getOwaspDescription('privacy_violation', risk.privacy_violation);
      factorText.push(`${t?.ui?.pdf_privacy || 'Privacy'}: ${risk.privacy_violation} (${desc})`);
    }
    
    if (factorText.length > 0) {
      const factorLines = pdf.splitTextToSize(factorText.join(', '), pageWidth - 80);
      pdf.text(factorLines, 70, yPosition);
      yPosition += factorLines.length * 3 + 2;
    }
  }

  return yPosition;
};

// Función auxiliar para agregar métricas y recomendaciones
const addMetricsAndRecommendations = async (
  pdf, 
  threats, 
  getCurrentRiskValue, 
  getRiskValue, 
  getResidualRiskValue, 
  getRiskLabel,
  pageWidth, 
  pageHeight, 
  t
) => {
  if (threats.length > 0) {
    pdf.addPage();
    let yPosition = 20;
    
    // Título de métricas
    pdf.setFontSize(16);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t?.ui?.pdf_metrics_title || 'Risk Metrics & Recommendations', 20, yPosition);
    yPosition += 15;
    
    // Distribución de riesgos
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t?.ui?.pdf_risk_distribution || 'Risk Distribution', 20, yPosition);
    yPosition += 10;
    
    const riskDistribution = {
      high: threats.filter(t => getCurrentRiskValue(t.id) >= 6).length,
      medium: threats.filter(t => getCurrentRiskValue(t.id) >= 3 && getCurrentRiskValue(t.id) < 6).length,
      low: threats.filter(t => getCurrentRiskValue(t.id) < 3).length
    };
    
    const total = threats.length;
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`${t?.ui?.pdf_high_risk || 'High Risk'} (6.0-9.0): ${riskDistribution.high} ${t?.ui?.threats?.toLowerCase() || 'threats'} (${((riskDistribution.high/total)*100).toFixed(1)}%)`, 25, yPosition);
    yPosition += 5;
    pdf.text(`${t?.ui?.pdf_medium_risk || 'Medium Risk'} (3.0-5.9): ${riskDistribution.medium} ${t?.ui?.threats?.toLowerCase() || 'threats'} (${((riskDistribution.medium/total)*100).toFixed(1)}%)`, 25, yPosition);
    yPosition += 5;
    pdf.text(`${t?.ui?.pdf_low_risk || 'Low Risk'} (0.0-2.9): ${riskDistribution.low} ${t?.ui?.threats?.toLowerCase() || 'threats'} (${((riskDistribution.low/total)*100).toFixed(1)}%)`, 25, yPosition);
    yPosition += 15;
    
    // Estado de remediaciones
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t?.ui?.pdf_remediation_status_section || 'Remediation Status', 20, yPosition);
    yPosition += 10;
    
    const remediationStats = {
      applied: threats.filter(t => t.remediation?.status).length,
      notApplied: threats.filter(t => !t.remediation?.status).length
    };
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(`${t?.ui?.pdf_remediated_threats || 'Remediated Threats:'} ${remediationStats.applied} (${((remediationStats.applied/total)*100).toFixed(1)}%)`, 25, yPosition);
    yPosition += 5;
    pdf.text(`${t?.ui?.pdf_not_remediated || 'Not Remediated:'} ${remediationStats.notApplied} (${((remediationStats.notApplied/total)*100).toFixed(1)}%)`, 25, yPosition);
    yPosition += 15;
    
    // Recomendaciones basadas en el análisis
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text(t?.ui?.pdf_key_recommendations || 'Key Recommendations', 20, yPosition);
    yPosition += 10;
    
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    
    const recommendations = [];
    
    if (riskDistribution.high > 0) {
      recommendations.push(`${t?.ui?.pdf_rec_prioritize || '• Prioritize immediate action on'} ${riskDistribution.high} ${t?.ui?.pdf_rec_high_risk || 'high-risk threat(s)'}`);
    }
    
    if (remediationStats.notApplied > remediationStats.applied) {
      recommendations.push(`${t?.ui?.pdf_rec_focus_remediation || '• Focus on implementing remediations'} (${remediationStats.notApplied} ${t?.ui?.pdf_rec_pending || 'pending'})`);
    }
    
    const manualResidualCount = threats.filter(t => getResidualRiskValue(t.id) !== getRiskValue(t.id)).length;
    if (manualResidualCount > 0) {
      recommendations.push(`${t?.ui?.pdf_rec_review || '• Review'} ${manualResidualCount} ${t?.ui?.pdf_rec_manual_residual || 'manually adjusted residual risk assessment(s)'}`);
    }
    
    if (riskDistribution.medium > riskDistribution.high && riskDistribution.medium > riskDistribution.low) {
      recommendations.push(`${t?.ui?.pdf_rec_consider || '• Consider risk reduction strategies for'} ${riskDistribution.medium} ${t?.ui?.pdf_rec_medium_threats || 'medium-risk threats'}`);
    }
    
    if (recommendations.length === 0) {
      recommendations.push(t?.ui?.pdf_rec_continue || '• Continue monitoring and maintaining current security posture');
      recommendations.push(t?.ui?.pdf_rec_regular || '• Regular risk assessment reviews are recommended');
    }
    
    recommendations.forEach(rec => {
      const recLines = pdf.splitTextToSize(rec, pageWidth - 50);
      pdf.text(recLines, 25, yPosition);
      yPosition += recLines.length * 5 + 2;
    });
    
    yPosition += 10;
    
    // Nota sobre OWASP
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'italic');
    pdf.setTextColor(100, 100, 100);
    const owaspNote = t?.ui?.pdf_owasp_note || 'Note: Risk calculations are based on OWASP Risk Rating methodology. Current Risk reflects inherent risk when no remediation is applied, and residual risk when remediation is implemented.';
    const owaspLines = pdf.splitTextToSize(owaspNote, pageWidth - 40);
    pdf.text(owaspLines, 20, yPosition);
    pdf.setTextColor(0, 0, 0);
  }
};

export default ReportGenerator;
